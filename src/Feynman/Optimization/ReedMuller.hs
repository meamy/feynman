module Feynman.Optimization.ReedMuller where

import Data.List
import Data.Ord
import Data.Tuple
import Data.Bits
import Data.Map (Map)
import qualified Data.Map as Map

import Control.Monad.Writer

import Feynman.Core
import Feynman.Algebra.Base
import Feynman.Algebra.Linear
import Feynman.Algebra.Polynomial.Multilinear
import Feynman.Synthesis.Reversible

{-- Reed-Muller decoding -}
{- Provides methods related to the decoding of Reed-Muller codes -}

-- Maximal dimension k-covering
-------------------------------------------------------------
-- The intuition of this algorithm is that we want to find
-- dimension k subspaces (k-flats) that contain a maximal
-- number of points/parities. k-flats correspond to codewords
-- of the Reed-Muller codes, so if at least half of the points
-- lie in the k-flat (of relevant dimension) we can add the
-- entire flat, resulting in a reduction of the number of
-- T gates
--
-- Thanks to Alex S. Foreskan for the idea

-- For future reference (MaxWilliams & Sloane):
--   - RM(r, m) is generated by the (m-r)-flats in EG(m,2) ~ F2^m
--   - RM(r, m) = {u|u+v for u in RM(r, m-1) v in RM(r-1,m-1)}
--   - RM(k, m) is contained in RM(k+1, m+1) in the sense that 0|v
--      is in RM(k+1, m+1)
--   - A flat is the set of solutions to a system of linear equations
--
-- Conjecture: Codewords of RM(n-4, n) are natively in C(n)

type PhasePoly a = Map F2Vec a

maximalkFlat :: Int -> [F2Vec] -> [F2Vec]
maximalkFlat k xs = maximumBy' (comparing length) . map go . choose k $ xs where
  go a = let f = inLinearSpan a in
    foldr (\vec acc -> if not (elem vec acc) && f vec then vec:acc else acc) a xs

-- Adds missing points to the flat
completeFlat :: [F2Vec] -> [F2Vec]
completeFlat xs = foldr go [] (vals mat) where
  (mat, _) = runWriter . toEchelon . fromList $ xs
  go v []  = [v]
  go v acc = if popCount v > 0 then acc ++ map (`xor` v) acc else acc

-- k-flat based optimization
optimizePP :: Int -> PhasePoly Angle -> PhasePoly Angle
optimizePP k pp =
  let maxflat      = maximalkFlat k . Map.keys . Map.filter tphase $ pp
      allflat      = filter (/= 0) $ completeFlat maxflat 
      pp'          = Map.fromList $ zip allflat (repeat $ Discrete (dMod2 7 3))
      add          = Map.unionWith (+)
      tphase theta = order theta >= 8
  in
    case length maxflat >= (1 `shiftL` (k-1)) of
      False -> pp
      True  -> optimizePP k (add pp pp')

{-- TOOL/TODD based optimizations -}

packPP :: PhasePoly DMod2 -> PhasePolynomial String DMod2
packPP = ofTermList . map (swap . go) . Map.toList where
  go (bv, angle) = (packBV bv, angle)
  packBV = monomial . concatMap (\(i,b) -> if b then [("x" ++ show i)] else []) . zip [0..] . toBits

unpackPP :: Int -> PhasePolynomial String DMod2 -> PhasePoly DMod2
unpackPP d = Map.fromList . map (go . swap) . toTermList where
  go (m, a) = (unpackM m, a)
  unpackM m = fromBits $ map (\i -> if ("x" ++ show i) `elem` vars m then True else False) [0..d-1]

splitPP :: PhasePoly Angle -> (PhasePoly DMod2, PhasePoly Double)
splitPP = Map.mapEither f where
  f (Discrete d)   = Left d
  f (Continuous r) = Right r

recombinePP :: (PhasePoly DMod2, PhasePoly Double) -> PhasePoly Angle
recombinePP (a,b) = Map.union (Map.map Discrete a) (Map.map Continuous b)

invFourierBV :: F2Vec -> PhasePoly DyadicRational
invFourierBV = Map.fromList . map (\bv -> (bv, dyadic ((-2)^(wt bv - 1)) 0)) . subsets
  where subsets = filter (/= 0) . map fromBits . go . toBits
        go []        = [[]]
        go (True:xs) = let rest = go xs in (map (False:) rest) ++ (map (True:) rest)
        go (_:xs)    = map (False:) $ go xs

invFourierPP :: PhasePoly DMod2 -> PhasePoly DMod2
invFourierPP = Map.filter (/= 0) . Map.map fromDyadic . foldr (Map.unionWith (+)) Map.empty . go
  where go = map (\(bv,a) -> Map.map (* (unpack a)) $ invFourierBV bv) . Map.toList

fourierBV :: F2Vec -> PhasePoly DyadicRational
fourierBV m = Map.fromList . map (\bv -> (bv, dyadic ((-1)^(wt bv - 1)) (wt m - 1))) $ subsets m
  where subsets = filter (/= 0) . map fromBits . go . toBits
        go []        = [[]]
        go (True:xs) = let rest = go xs in (map (False:) rest) ++ (map (True:) rest)
        go (_:xs)    = map (False:) $ go xs

fourierPP :: PhasePoly DMod2 -> PhasePoly DMod2
fourierPP = Map.filter (/= 0) . Map.map fromDyadic . foldr (Map.unionWith (+)) Map.empty . go
  where go = map (\(bv,a) -> Map.map (* (unpack a)) $ fourierBV bv) . Map.toList

sliceOrder :: Int -> PhasePoly DMod2 -> PhasePoly DMod2
sliceOrder k = Map.mapMaybeWithKey go where
  go bv 0 = Nothing
  go bv 1 = if wt bv == k then Just 1 else Nothing
  go bv a = case compare (denomExp (unpack a) + wt bv) k of
    LT -> Nothing
    EQ -> Just $ dMod2 (numer (unpack a) `mod` 2) (denomExp (unpack a))
    GT ->
      let bit = (shiftR (numer $ unpack a) (k - wt bv)) `mod` 2 in
        if bit == 0 then Nothing else Just $ dMod2 1 (k - wt bv)

addPP :: Num a => PhasePoly a -> PhasePoly a -> PhasePoly a
addPP = Map.unionWith (+)

subPP :: Num a => PhasePoly a -> PhasePoly a -> PhasePoly a
subPP = Map.unionWith (-)

getConstantPP :: Num a => PhasePoly a -> a
getConstantPP = Map.findWithDefault 0 0

dropConstantPP :: Num a => PhasePoly a -> PhasePoly a
dropConstantPP = Map.delete 0

-- TOOL optimization
--
-- 1. Split into discrete parts
-- 2. Convert to multiplicative poly
-- 3. Reduce to third order parts
-- 4. Factor as yf_0 + f_1
-- 5. Minimize Fourier expansion of f_0 via Lempel's algorithm
-- 6. Synthesize terms containing y and remove from poly
-- 7. Go to step 4
{-
toolOptimize :: PhasePoly Angle -> PhasePoly Angle
toolOptimize pp = recombine (pd', pc) where
  d        = maximum . map width . Map.keys $ pp
  (pd, pc) = splitPP pp
  pd'      = unpackPP d . go . invFourier . packPP $ pd

  go :: PseudoBoolean DMod2 -> PhasePolynomial DMod2
  go pp
    | isConst pp = constant $ getConstant pp
    | otherwise  =
      let v      = head $ vars pp -- Change to dominant variable eventually
          f0     = quotVar v pp
          f0Impl = packPP . lempel . unpackPP d . fourier $ f0



toolSynth :: PseudoBoolean DMod2 -> PhasePolynomial DMod2
toolSynth pp
  | isConst pp = constant $ getConstant pp
  | otherwise  =
    let v      = head $ vars pp -- Change to dominant variable eventually
        f0     = quotVar v pp
        f0Impl = packPP . lempel . unpackPP d . fourier $ f0
-}

-- Expands a third-order multiplicative polynomial
toolSynth :: Int -> PhasePoly DMod2 -> PhasePoly DMod2
toolSynth d pp = go pp [0..d-1] where
  lempel'      = toList . lempel . fromList

  setI i       = (bitI d i +)

  cofactor i   = (\(f0,f1) -> (Map.mapKeys (setI i) f0, f1)) . Map.partitionWithKey (\bv a -> bv@.i)

  go :: PhasePoly DMod2 -> [Int] -> PhasePoly DMod2
  go _ []      = Map.empty
  go pp (i:xs) =
    let (f0,f1) = cofactor i pp
        (c,f0') = (getConstantPP f0, dropConstantPP f0)
        f0Imp   = Map.fromList . flip zip (repeat $ dMod2 1 1) . lempel' . Map.keys $ fourierPP f0'
        poly    = Map.insert (bitI d i) (c + dMod2 (toInteger $ Map.size f0Imp) 2) $
                  Map.mapKeys (setI i) $
                  Map.map (negate) f0Imp
    in
      addPP poly $ go (addPP f0' f1) xs

-- Expands a third-order multiplicative polynomial
toolSliceSynth :: PhasePoly DMod2 -> PhasePoly DMod2
toolSliceSynth pp = if Map.null pp then Map.empty else go pp [0..d-1] where
  d            = width . head . Map.keys $ pp
  lempel'      = toList . lempel . fromList
  setI i       = (bitI d i +)
  cofactor i   = (\(f0,f1) -> (Map.mapKeys (setI i) f0, f1)) . Map.partitionWithKey (\bv a -> bv@.i)

  go :: PhasePoly DMod2 -> [Int] -> PhasePoly DMod2
  go pp []         = fourierPP pp
  go pp (i:xs)     =
    let pp'     = sliceOrder 3 pp
        (f0,f1) = cofactor i pp'
        (c,f0') = (getConstantPP f0, dropConstantPP f0)
        f0Imp   = Map.fromList . flip zip (repeat $ dMod2 1 1) . lempel' . Map.keys $ fourierPP f0'
        poly    = Map.insert (bitI d i) (c + dMod2 (toInteger $ Map.size f0Imp) 2) $
                  Map.mapKeys (setI i) $
                  Map.map (negate) f0Imp
    in
      addPP poly $ go (subPP pp $ invFourierPP poly) xs

rmWrap :: Synthesizer -> Synthesizer
rmWrap synth = \input output must -> synth input output (opt must) where
  opt must = let (pd, pc) = splitPP (Map.fromList must) in
    Map.toList $ recombinePP (toolSliceSynth $ invFourierPP pd, pc)

rmSynth :: [Phase] -> [Phase]
rmSynth xs = Map.toList $ recombinePP (toolSliceSynth $ invFourierPP pd, pc) where
  (pd, pc) = splitPP (Map.fromList xs)

-- Utilities
choose :: Int -> [a] -> [[a]]
choose k []     = []
choose 0 _      = []
choose 1 (x:_)  = [[x]]
choose k (x:xs) = choose k xs ++ map (x:) (choose (k-1) xs)

maximumBy' f [] = []
maximumBy' f xs = maximumBy f xs

-- Testing
x1 = bitI 5 0
x2 = bitI 5 1
x3 = bitI 5 2
x4 = bitI 5 3
x5 = bitI 5 4

vecs = [x1 `xor` x5,
        x2 `xor` x3,
        x2,
        x1,
        x1 `xor` x2 `xor` x3 `xor` x4 `xor` x5,
        x5,
        x3 `xor` x4,
        x3 `xor` x5,
        x1 `xor` x3 `xor` x4 `xor` x5,
        x2 `xor` x3 `xor` x4,
        x2 `xor` x5,
        x1 `xor` x2 `xor` x4]

checkMod8 :: [F2Vec] -> Bool
checkMod8 []     = True
checkMod8 (x:xs) = all go $ allVecs (width x) where
  go v        = foldr (+) 0 (map (parity v) $ x:xs) `mod` 8 == 0
  parity v v' = popCount (v .&. v') `mod` 2

testPoly :: PhasePoly DMod2
testPoly = Map.fromList $ zip [bitVec 4 i | i <- [1..14]] (repeat $ dMod2 1 2)
