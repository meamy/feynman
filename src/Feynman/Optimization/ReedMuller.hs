module Feynman.Optimization.ReedMuller where

import Data.List
import Data.Ord
import Data.Tuple
import Data.Bits
import Data.Map (Map)
import qualified Data.Map as Map

import Control.Monad.Writer

import Feynman.Core
import Feynman.Algebra.Base
import Feynman.Algebra.Linear
import Feynman.Algebra.Polynomial.Multilinear
import Feynman.Synthesis.Reversible

{-- Reed-Muller decoding -}
{- Provides methods related to the decoding of Reed-Muller codes -}

-- Maximal dimension k-covering
-------------------------------------------------------------
-- The intuition of this algorithm is that we want to find
-- dimension k subspaces (k-flats) that contain a maximal
-- number of points/parities. k-flats correspond to codewords
-- of the Reed-Muller codes, so if at least half of the points
-- lie in the k-flat (of relevant dimension) we can add the
-- entire flat, resulting in a reduction of the number of
-- T gates
--
-- Thanks to Alex S. Foreskan for the idea

-- For future reference (MaxWilliams & Sloane):
--   - RM(r, m) is generated by the (m-r)-flats in EG(m,2) ~ F2^m
--   - RM(r, m) = {u|u+v for u in RM(r, m-1) v in RM(r-1,m-1)}
--   - RM(k, m) is contained in RM(k+1, m+1) in the sense that 0|v
--      is in RM(k+1, m+1)
--   - A flat is the set of solutions to a system of linear equations
--
-- Conjecture: Codewords of RM(n-4, n) are natively in C(n)

type PhasePoly = Map F2Vec Angle

maximalkFlat :: Int -> [F2Vec] -> [F2Vec]
maximalkFlat k xs = maximumBy' (comparing length) . map go . choose k $ xs where
  go a = let f = inLinearSpan a in
    foldr (\vec acc -> if not (elem vec acc) && f vec then vec:acc else acc) a xs

-- Adds missing points to the flat
completeFlat :: [F2Vec] -> [F2Vec]
completeFlat xs = foldr go [] (vals mat) where
  (mat, _) = runWriter . toEchelon . fromList $ xs
  go v []  = [v]
  go v acc = if popCount v > 0 then acc ++ map (`xor` v) acc else acc

-- k-flat based optimization
optimizePP :: Int -> PhasePoly -> PhasePoly
optimizePP k pp =
  let maxflat      = maximalkFlat k . Map.keys . Map.filter tphase $ pp
      allflat      = filter (/= 0) $ completeFlat maxflat 
      pp'          = Map.fromList $ zip allflat (repeat $ Discrete (dMod2 7 3))
      add          = Map.unionWith (+)
      tphase theta = order theta >= 8
  in
    case length maxflat >= (1 `shiftL` (k-1)) of
      False -> pp
      True  -> optimizePP k (add pp pp')

{-- TOOL/TODD based optimizations -}

pack :: Map F2Vec DMod2 -> PhasePolynomial String DMod2
pack = ofTermList . map (swap . go) . Map.toList where
  go (bv, angle) = (packBV bv, angle)
  packBV = monomial . concatMap (\(i,b) -> if b then [("x" ++ show i)] else []) . zip [0..] . toBits

unpack :: Int -> PhasePolynomial String DMod2 -> Map F2Vec DMod2
unpack d = Map.fromList . map (go . swap) . toTermList where
  go (m, a) = (unpackM m, a)
  unpackM m = fromBits $ map (\i -> if ("x" ++ show i) `elem` vars m then True else False) [0..d-1]

-- TOOL optimization
--
-- 1. Split into discrete parts
-- 2. Convert to multiplicative poly
-- 3. Reduce to third order parts
-- 4. Factor as yf_0 + f_1
-- 5. Minimize Fourier expansion of f_0 via Lempel's algorithm
-- 6. Synthesize terms containing y and remove from poly
-- 7. Go to step 4
{-
toolOptimize :: PhasePoly -> PhasePoly
toolOptimize pp = do
  let 
  let maxflat      = maximalkFlat k . Map.keys . Map.filter tphase $ pp
      allflat      = filter (/= 0) $ completeFlat maxflat 
      pp'          = Map.fromList $ zip allflat (repeat $ Discrete (dMod2 7 3))
      add          = Map.unionWith (+)
      tphase theta = order theta >= 8
  in
    case length maxflat >= (1 `shiftL` (k-1)) of
      False -> pp
      True  -> optimizePP k (add pp pp')
-}

rmWrap :: Synthesizer -> Synthesizer
rmWrap synth = synth' where
  synth' input output must = synth input output must' where
    must' = Map.toList . optimizePP 5 . optimizePP 4 . Map.fromList $ must

-- Utilities
choose :: Int -> [a] -> [[a]]
choose k []     = []
choose 0 _      = []
choose 1 (x:_)  = [[x]]
choose k (x:xs) = choose k xs ++ map (x:) (choose (k-1) xs)

maximumBy' f [] = []
maximumBy' f xs = maximumBy f xs

-- Testing
x1 = bitI 5 0
x2 = bitI 5 1
x3 = bitI 5 2
x4 = bitI 5 3
x5 = bitI 5 4

vecs = [x1 `xor` x5,
        x2 `xor` x3,
        x2,
        x1,
        x1 `xor` x2 `xor` x3 `xor` x4 `xor` x5,
        x5,
        x3 `xor` x4,
        x3 `xor` x5,
        x1 `xor` x3 `xor` x4 `xor` x5,
        x2 `xor` x3 `xor` x4,
        x2 `xor` x5,
        x1 `xor` x2 `xor` x4]

checkMod8 :: [F2Vec] -> Bool
checkMod8 []     = True
checkMod8 (x:xs) = all go $ allVecs (width x) where
  go v        = foldr (+) 0 (map (parity v) $ x:xs) `mod` 8 == 0
  parity v v' = popCount (v .&. v') `mod` 2

testPoly :: PhasePoly
testPoly = Map.fromList $ zip (allVecs 4) (repeat $ Discrete (dMod2 1 3))
