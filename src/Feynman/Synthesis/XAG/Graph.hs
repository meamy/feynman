{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE InstanceSigs #-}

module Feynman.Synthesis.XAG.Graph
  ( Node (..),
    Graph (..),
    cover,
    dominatingAnds,
    eval,
    freeVariables,
    nodeRefs,
    -- normalize,
    outputs,
    valid,
    validNodes,
  )
where

import Data.Bits (Bits (xor, (.&.)))
import Data.IntMap qualified as IntMap
import Data.IntSet qualified as IntSet
import Data.List (sort)
import GHC.Float (sqrtFloat)
import GHC.Generics (Generic)
import Test.QuickCheck qualified as QC

-- The Graph is a list of Node; each node has a nodeID, uniquely identifying it.
-- Nodes are ordered by increasing nodeID, and the graph should be acyclic, with
-- each Node referring only to prior XagNodes via its inputs i.e. topologically
-- sorted. References to nodeIDs not in the list are free variables.

-- Although we include Const nodes for flexibility, you can eliminate them from
-- any graph by transforming to a graph that applies Not to free variables
-- (assuming there are free variables in the graph to start with, that is -- if
-- there are not then the graph isn't very interesting, of course).

-- Alternatively, we could have included just Const True, and not Not, by
-- substituting (Xor True x) for (Not x). This would also be obfuscatory for the
-- kind of input and output we deal with.

data Node
  = Const {nodeID :: !Int, value :: !Bool}
  | Not {nodeID :: !Int, xIn :: !Int}
  | Xor {nodeID :: !Int, xIn :: !Int, yIn :: !Int}
  | And {nodeID :: !Int, xIn :: !Int, yIn :: !Int}
  deriving (Eq, Generic, Read, Show)

instance Ord Node where
  compare :: Node -> Node -> Ordering
  compare x y
    | nidOrd == EQ = compareType x y
    | otherwise = nidOrd
    where
      nidOrd = compare (nodeID x) (nodeID y)
      -- Same-type: drill down
      compareType (Const _ xVal) (Const _ yVal) = compare xVal yVal
      compareType (Not _ xXIn) (Not _ yXIn) = compare xXIn yXIn
      compareType (Xor _ xXIn xYIn) (Xor _ yXIn yYIn) = compare xXIn yXIn <> compare xYIn yYIn
      compareType (And _ xXIn xYIn) (And _ yXIn yYIn) = compare xXIn yXIn <> compare xYIn yYIn
      -- Different-type: early out
      compareType (Const {}) _ = LT
      compareType (Not {}) _ = LT
      compareType (Xor {}) _ = LT
      compareType (And {}) _ = undefined

class Graph g where
  inputIDs :: g -> [Int]
  inputIDSet :: g -> IntSet.IntSet
  inputIDSet = IntSet.fromList . inputIDs
  outputIDs :: g -> [Int]
  outputIDSet :: g -> IntSet.IntSet
  outputIDSet = IntSet.fromList . outputIDs
  nodes :: g -> [Node]
  nodeIDs :: g -> [Int]
  nodeIDs = map nodeID nodes
  nodeIDSet :: g -> IntSet.IntSet
  nodeIDSet = IntSet.fromList . nodeIDs
  valid :: g -> Bool
  topologicalIDs :: g -> [Int]
  topologicalIDs = (map nodeID) . topologicalNodes
  topologicalNodes :: g -> [Node]
  freeVariables :: g -> IntSet.IntSet
  internal :: g -> IntSet.IntSet
  coverIDs :: IntSet.IntSet -> g -> IntSet.IntSet
  coverIDs ids = (map nodeID) . (coverNodes ids)
  coverNodes :: IntSet.IntSet -> g -> [Node]
  substitute :: Graph h => g -> [Int] -> h -> g

data Graph = Graph {nodes :: [Node], inputIDs :: [Int], outputIDs :: [Int]}
  deriving (Eq, Generic, Ord, Read, Show)

-- compute the set of free variables used by this graph
freeVariables :: [Node] -> IntSet.IntSet
freeVariables allNodes = freeVariablesRev (reverse allNodes) IntSet.empty
  where
    freeVariablesRev [] freeSoFar = freeSoFar
    freeVariablesRev (node : nodes) freeSoFar =
      IntSet.delete
        (nodeID node)
        (freeVariablesRev nodes (IntSet.union (nodeRefs node) freeSoFar))

-- compute the list of outputs possibly generated by this graph
outputs :: [Node] -> IntSet.IntSet
outputs nodes = IntSet.fromList (map nodeID nodes)

-- countAnd :: Graph -> Int
-- countAnd (Graph nodes) = foldr (\node -> case And _ _ -> 1; _ -> 0) 0 nodes

-- countAndInputs :: Graph -> Int
-- countAndInputs (Graph nodes) = foldr (\node -> case And _ ins -> length ins; _ -> 0) 0 nodes

-- compute a subset of the graph producing the given outputs
cover :: IntSet.IntSet -> [Node] -> [Node]
cover initialIDs allNodes = reverse (coverRev initialIDs (reverse allNodes))
  where
    coverRev _ [] = []
    coverRev coverIDs (node : nodes) =
      if IntSet.member (nodeID node) coverIDs
        then node : coverRev (IntSet.union coverIDs (nodeRefs node)) nodes
        else coverRev coverIDs nodes

-- The returns from this are a list of And nodes And-directly dominating the
-- ofID node -- that is, the dominators may be separated by Xor or Not nodes,
-- but there aren't any intervening Ands.
-- The returned list contains tuples with the node id of the dominating And,
-- the id of the node that And was reached via, and the id of the node it
-- wasn't reached via. In the case that a dominator is reached via multiple
-- paths simultaneously, the node will appear twice in the list with both node
-- orders.
dominatingAnds :: Int -> [Node] -> [(Int, (Int, Int))]
dominatingAnds ofID allNodes = dominatingAndsOfID (IntSet.singleton ofID) (skipToNode allNodes)
  where
    -- Don't even start looking until after the subject node
    skipToNode :: [Node] -> [Node]
    skipToNode [] = []
    skipToNode wholeList@(node : nodes)
      | nodeID node > ofID = wholeList
      | otherwise = skipToNode nodes

    dominatingAndsOfID :: IntSet.IntSet -> [Node] -> [(Int, (Int, Int))]
    dominatingAndsOfID _ [] = []
    dominatingAndsOfID searchSet (node : nodes) =
      case node of
        -- Const nodes can't dominate anything
        Const _ _ -> dominatingAndsOfID searchSet nodes
        -- Not: Add this node to the search list if it's controlled by anything in the search list
        Not nID xID -> dominatingAndsOfID (expandSearchIf (IntSet.member xID searchSet) nID) nodes
        -- Xor: Add this node to the search list if it's controlled by anything in the search list
        Xor nID xID yID -> dominatingAndsOfID (expandSearchIf (IntSet.member xID searchSet || IntSet.member yID searchSet) nID) nodes
        -- And gate found! But don't go looking for And dominating And, we only look 1 deep
        And nID xID yID -> withXYDoms
          where
            withXYDoms = if IntSet.member xID searchSet then (nID, (xID, yID)) : withYDoms else withYDoms
            withYDoms = if IntSet.member yID searchSet then (nID, (yID, xID)) : restOfDoms else restOfDoms
            restOfDoms = dominatingAndsOfID searchSet nodes
      where
        expandSearchIf False _ = searchSet
        expandSearchIf True nID = IntSet.insert nID searchSet

nodeRefs :: Node -> IntSet.IntSet
nodeRefs (Not _ x) = IntSet.singleton x
nodeRefs (Xor _ x y) = IntSet.fromList [x, y]
nodeRefs (And _ x y) = IntSet.fromList [x, y]
nodeRefs _ = IntSet.empty

valid :: Graph -> Bool
valid (Graph {nodes = ns, inputIDs = inIDs, outputIDs = outIDs}) =
  -- node list is valid according to those basic rules
  validNodes ns
    -- no dups in the input order (that would mean a double-assignment)
    && (IntSet.size inIDSet == length inIDs)
    -- inputIDs completely specifies the free variables (but inputs may be disconnected)
    && IntSet.isSubsetOf freeVarSet inIDSet
    -- outputIDs may have dups
    -- outputIDs may only refer to inputIDs and actual outputs
    && IntSet.isSubsetOf outIDSet (IntSet.union outSet inIDSet)
  where
    inIDSet = IntSet.fromList inIDs
    outIDSet = IntSet.fromList outIDs
    freeVarSet = freeVariables ns
    outSet = outputs ns

-- checks properties of nodeID order and uniqueness, and acyclic refs
validNodes :: [Node] -> Bool
validNodes = validNodesAux 0
  where
    validNodesAux _ [] = True
    validNodesAux nextID (node : nodes) =
      validNode nextID node && validNodesAux (nodeID node + 1) nodes
    validNode nextID (Const n _) = n >= nextID
    validNode nextID (Not n x) = (n >= nextID) && validInput n x
    validNode nextID (Xor n x y) = (n >= nextID) && validInput n x && validInput n y
    validNode nextID (And n x y) = (n >= nextID) && validInput n x && validInput n y
    -- validNode nextID (Var n) = n >= nextID

    validInput :: Int -> Int -> Bool
    validInput n x = (x >= 0) && (x < n)

eval :: Graph -> [Bool] -> Maybe [Bool]
eval g@(Graph nodes inIDs outIDs) inVec
  | not (valid g) = Nothing
  | not (IntSet.null (freeVariables simNodes)) = Nothing
  | otherwise =
      let resMap = foldl doEval IntMap.empty simNodes
       in Just $ map (resMap IntMap.!) outIDs
  where
    doEval :: IntMap.IntMap Bool -> Node -> IntMap.IntMap Bool
    doEval res (Const nid val) = IntMap.insert nid val res
    doEval res (Not nid xID) = IntMap.insert nid (not $ res IntMap.! xID) res
    doEval res (Xor nid xID yID) = IntMap.insert nid ((res IntMap.! xID) `xor` (res IntMap.! yID)) res
    doEval res (And nid xID yID) = IntMap.insert nid ((res IntMap.! xID) .&. (res IntMap.! yID)) res

    simNodes = sort (fixVars ++ nodes)
    fixVars = zipWith Const inIDs inVec

-- andCost :: (Num b) => Graph a -> b
-- andCost g = eval g (+) (\x y -> x + y + 1) (const 0)

-- The Arbitrary makes a valid, arbitrary Graph with a gap for free variables,
-- and then a number of Not, Xor, and And nodes to fill the list to the
-- arbitrary size. Inputs are weighted to prefer earlier nodes, so as to bias
-- towards shallower graphs.
instance QC.Arbitrary Graph where
  arbitrary :: QC.Gen Graph
  arbitrary = do
    nNodes <- QC.getSize
    let nVars = (ceiling . sqrtFloat . fromIntegral) nNodes + 1
    nodes <- mapM genNode [nVars .. nVars + nNodes - 1]
    randIns <- QC.shuffle [0 .. nVars - 1]
    let allOutputs = map nodeID nodes
    outShuf <- QC.shuffle allOutputs
    randOuts <- QC.sublistOf outShuf
    return $ Graph {nodes = nodes, inputIDs = randIns, outputIDs = randOuts}
    where
      genNode n = do
        QC.frequency [(1, genConstNode n), (10, genNotNode n), (20, genXANode n)]

      genConstNode n = do
        val <- QC.oneof [return True, return False]
        return $ Const n val

      genNotNode n = do
        xInput <- genIndex n
        return $ Not n xInput

      genXANode n = QC.oneof [genBinary n Xor, genBinary n And]

      genBinary :: Int -> (Int -> Int -> Int -> Node) -> QC.Gen Node
      genBinary n xa = do
        xInput <- genIndex n
        yInput <- genIndex n
        return $ xa n xInput yInput

      genIndex 0 = undefined
      genIndex n = do
        unbiased <- QC.choose (0, n * n - 1)
        return $ unbiased `div` n
