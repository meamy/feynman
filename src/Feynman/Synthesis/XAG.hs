module Feynman.Synthesis.XAG (Graph(..), Node(..), fromSBools, optimize, pretty, valid) where

import Control.Exception (assert)
import Control.Monad
import Control.Monad.State.Strict
import Data.IntSet (IntSet)
import qualified Data.IntSet as IntSet
import Data.Set (Set)
import qualified Data.Set as Set
import Logic.MockTurtle
import Logic.MockTurtle.XAG
import Feynman.Algebra.Base
import Feynman.Algebra.Pathsum.Balanced
import Feynman.Algebra.Polynomial.Multilinear

-- compute the set of free variables used by this graph
freeVariables :: [Node] -> IntSet.IntSet
freeVariables allNodes = freeVariablesRev (reverse allNodes) IntSet.empty
  where
    freeVariablesRev [] freeSoFar = freeSoFar
    freeVariablesRev (node : nodes) freeSoFar =
      IntSet.delete
        (nodeID node)
        (freeVariablesRev nodes (IntSet.union (nodeRefs node) freeSoFar))

nodeRefs :: Node -> IntSet.IntSet
nodeRefs (Not _ x) = IntSet.singleton x
nodeRefs (Xor _ x y) = IntSet.fromList [x, y]
nodeRefs (And _ x y) = IntSet.fromList [x, y]
nodeRefs _ = IntSet.empty

-- compute the list of outputs possibly generated by this graph
outputs :: [Node] -> IntSet.IntSet
outputs nodes = IntSet.fromList (map nodeID nodes)

-- The Graph is a list of Node; each node has a nodeID, uniquely identifying it.
-- Nodes are ordered by increasing nodeID, and the graph should be acyclic, with
-- each Node referring only to prior XagNodes via its inputs i.e. topologically
-- sorted. References to nodeIDs not in the list are free variables.
valid :: Graph -> Bool
valid (Graph {nodes = ns, inputIDs = inIDs, outputIDs = outIDs}) =
  -- node list is valid according to those basic rules
  validNodes ns
    -- no dups in the input order (that would mean a double-assignment)
    && (IntSet.size inIDSet == length inIDs)
    -- inputIDs completely specifies the free variables (but inputs may be disconnected)
    && IntSet.isSubsetOf freeVarSet inIDSet
    -- outputIDs may have dups
    -- outputIDs may only refer to inputIDs and actual outputs
    && IntSet.isSubsetOf outIDSet (IntSet.union outSet inIDSet)
  where
    inIDSet = IntSet.fromList inIDs
    outIDSet = IntSet.fromList outIDs
    freeVarSet = freeVariables ns
    outSet = outputs ns

-- checks properties of nodeID order and uniqueness, and topolgical order
validNodes :: [Node] -> Bool
validNodes = validNodesAux 0
  where
    validNodesAux _ [] = True
    validNodesAux nextID (node : nodes) =
      validNode nextID node && validNodesAux (nodeID node + 1) nodes
    validNode nextID (Const n _) = n >= nextID
    validNode nextID (Not n x) = (n >= nextID) && validInput n x
    validNode nextID (Xor n x y) = (n >= nextID) && validInput n x && validInput n y
    validNode nextID (And n x y) = (n >= nextID) && validInput n x && validInput n y
    -- validNode nextID (Var n) = n >= nextID

    validInput :: Int -> Int -> Bool
    validInput n x = (x >= 0) && (x < n)

-- Merge graphs using the given input mappings. Output will return a merged
-- input mapping, with outputs list [the first graph outputs] ++ [the second
-- graph outputs]
merge :: (Ord a) => [a] -> Graph -> [a] -> Graph -> ([a], Graph)
merge mapA graphA mapB graphB = undefined
  where
    foo = undefined

data GenState = GenState
  { gsNextID :: Int,
    gsNodes :: [Node]
  }

fromSBools :: Int -> [SBool Var] -> Graph
fromSBools nvars sbools
  -- all vars in all terms in all SBools must be IVar
  | assert (all (all (all isIVar . (vars . snd)) . toTermList) sbools) $
      assert (valid completeGraph) otherwise =
      completeGraph
  where
    completeGraph = Graph (reverse completeNodesRev) [0 .. nvars - 1] completeOutIDs 

    (completeOutIDs, GenState {gsNodes = completeNodesRev}) =
      runState fullGen (GenState nvars [])

    fullGen :: State GenState [Int]
    fullGen = mapM genSBool sbools

    genSBool :: SBool Var -> State GenState Int
    genSBool sbool = do
      let terms = toSynthesizableTerms id sbool
      termIDs <- mapM genTerm terms
      genTree Xor termIDs

    genTerm :: (FF2, [Int]) -> State GenState Int
    genTerm (1, varIDs) = genTree And varIDs
    genTerm (0, varIDs) = do
      error "Unexpected?"
      xID <- genTree And varIDs
      addNode (`Not` xID)

    genTree :: (Int -> Int -> Int -> Node) -> [Int] -> State GenState Int
    genTree ctor [] = error "Can't generate tree of 0 things"
    genTree ctor [xID] = return xID
    genTree ctor (xID : xs) = do
      yID <- genTree ctor xs
      addNode (\newID -> ctor newID xID yID)

    addNode :: (Int -> Node) -> State GenState Int
    addNode nodeF = do
      gs <- gets id
      let newNode = nodeF (gsNextID gs)
      put $ GenState (gsNextID gs + 1) (newNode : gsNodes gs)
      return $ nodeID newNode

isIVar (IVar _) = True
isIVar _ = False

toSynthesizableTerms :: (Int -> a) -> SBool Var -> [(FF2, [a])]
toSynthesizableTerms mapInput outPoly =
  -- Get all the monomial var sets as ID lists
  map (\(val, term) -> (val, termIDs term)) (toTermList outPoly)
  where
    -- Map each IVar in the monomial through the idList
    termIDs term = [mapInput i | IVar i <- Set.toList (vars term)]
